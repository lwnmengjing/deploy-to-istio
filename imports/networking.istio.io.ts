// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';

/**
 *
 *
 * @schema DestinationRule
 */
export class DestinationRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'DestinationRule'
  };

  /**
   * Renders a Kubernetes manifest for "DestinationRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleProps = {}): any {
    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(props)
    };
  }

  /**
   * Defines a "DestinationRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleProps = {}) {
    super(scope, id, {
      ...DestinationRule.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(resolved)
    };
  }
}

/**
 * @schema DestinationRule
 */
export interface DestinationRuleProps {
  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRule#spec
   */
  readonly spec?: DestinationRuleSpec;

  /**
   * @schema DestinationRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'DestinationRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleProps(obj: DestinationRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_DestinationRuleSpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleSpec
 */
export interface DestinationRuleSpec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleSpec#host
   */
  readonly host?: string;

  /**
   * @schema DestinationRuleSpec#subsets
   */
  readonly subsets?: DestinationRuleSpecSubsets[];

  /**
   * @schema DestinationRuleSpec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecTrafficPolicy;
}

/**
 * Converts an object of type 'DestinationRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpec(obj: DestinationRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exportTo: obj.exportTo?.map((y) => y),
    host: obj.host,
    subsets: obj.subsets?.map((y) => toJson_DestinationRuleSpecSubsets(y)),
    trafficPolicy: toJson_DestinationRuleSpecTrafficPolicy(obj.trafficPolicy)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsets
 */
export interface DestinationRuleSpecSubsets {
  /**
   * @schema DestinationRuleSpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleSpecSubsets#name
   */
  readonly name?: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleSpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecSubsetsTrafficPolicy;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsets(
  obj: DestinationRuleSpecSubsets | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    trafficPolicy: toJson_DestinationRuleSpecSubsetsTrafficPolicy(obj.trafficPolicy)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicy
 */
export interface DestinationRuleSpecTrafficPolicy {
  /**
   * @schema DestinationRuleSpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyTls;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicy(
  obj: DestinationRuleSpecTrafficPolicy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionPool: toJson_DestinationRuleSpecTrafficPolicyConnectionPool(obj.connectionPool),
    loadBalancer: toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    outlierDetection: toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    portLevelSettings: obj.portLevelSettings?.map((y) => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(y)),
    tls: toJson_DestinationRuleSpecTrafficPolicyTls(obj.tls)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicy
 */
export interface DestinationRuleSpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyTls;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicy(
  obj: DestinationRuleSpecSubsetsTrafficPolicy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionPool: toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    loadBalancer: toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    outlierDetection: toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    portLevelSettings: obj.portLevelSettings?.map((y) =>
      toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(y)
    ),
    tls: toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(obj.tls)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyConnectionPoolTcp;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPool(
  obj: DestinationRuleSpecTrafficPolicyConnectionPool | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(obj.http),
    tcp: toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(obj.tcp)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyLoadBalancerSimple;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancer | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    consistentHash: toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    localityLbSetting: toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    simple: obj.simple
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(
  obj: DestinationRuleSpecTrafficPolicyOutlierDetection | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    baseEjectionTime: obj.baseEjectionTime,
    consecutive5xxErrors: obj.consecutive5XxErrors,
    consecutiveErrors: obj.consecutiveErrors,
    consecutiveGatewayErrors: obj.consecutiveGatewayErrors,
    consecutiveLocalOriginFailures: obj.consecutiveLocalOriginFailures,
    interval: obj.interval,
    maxEjectionPercent: obj.maxEjectionPercent,
    minHealthPercent: obj.minHealthPercent,
    splitExternalLocalOriginErrors: obj.splitExternalLocalOriginErrors
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettings | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionPool: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    loadBalancer: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    outlierDetection: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    port: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(obj.port),
    tls: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(obj.tls)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyTls
 */
export interface DestinationRuleSpecTrafficPolicyTls {
  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyTls(
  obj: DestinationRuleSpecTrafficPolicyTls | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caCertificates: obj.caCertificates,
    clientCertificate: obj.clientCertificate,
    credentialName: obj.credentialName,
    mode: obj.mode,
    privateKey: obj.privateKey,
    sni: obj.sni,
    subjectAltNames: obj.subjectAltNames?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(
  obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    tcp: toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    consistentHash: toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    localityLbSetting: toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(
      obj.localityLbSetting
    ),
    simple: obj.simple
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(
  obj: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    baseEjectionTime: obj.baseEjectionTime,
    consecutive5xxErrors: obj.consecutive5XxErrors,
    consecutiveErrors: obj.consecutiveErrors,
    consecutiveGatewayErrors: obj.consecutiveGatewayErrors,
    consecutiveLocalOriginFailures: obj.consecutiveLocalOriginFailures,
    interval: obj.interval,
    maxEjectionPercent: obj.maxEjectionPercent,
    minHealthPercent: obj.minHealthPercent,
    splitExternalLocalOriginErrors: obj.splitExternalLocalOriginErrors
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectionPool: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    loadBalancer: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    outlierDetection: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(
      obj.outlierDetection
    ),
    port: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    tls: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(
  obj: DestinationRuleSpecSubsetsTrafficPolicyTls | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caCertificates: obj.caCertificates,
    clientCertificate: obj.clientCertificate,
    credentialName: obj.credentialName,
    mode: obj.mode,
    privateKey: obj.privateKey,
    sni: obj.sni,
    subjectAltNames: obj.subjectAltNames?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(
  obj: DestinationRuleSpecTrafficPolicyConnectionPoolHttp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    h2UpgradePolicy: obj.h2UpgradePolicy,
    http1MaxPendingRequests: obj.http1MaxPendingRequests,
    http2MaxRequests: obj.http2MaxRequests,
    idleTimeout: obj.idleTimeout,
    maxRequestsPerConnection: obj.maxRequestsPerConnection,
    maxRetries: obj.maxRetries,
    useClientProtocol: obj.useClientProtocol
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(
  obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTimeout: obj.connectTimeout,
    maxConnections: obj.maxConnections,
    tcpKeepalive: toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    httpCookie: toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    httpHeaderName: obj.httpHeaderName,
    httpQueryParameterName: obj.httpQueryParameterName,
    minimumRingSize: obj.minimumRingSize,
    useSourceIp: obj.useSourceIp
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    distribute: obj.distribute?.map((y) =>
      toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)
    ),
    enabled: obj.enabled,
    failover: obj.failover?.map((y) => toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y))
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = 'ROUND_ROBIN',
  /** LEAST_CONN */
  LEAST_CONN = 'LEAST_CONN',
  /** RANDOM */
  RANDOM = 'RANDOM',
  /** PASSTHROUGH */
  PASSTHROUGH = 'PASSTHROUGH'
}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    tcp: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    consistentHash: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(
      obj.consistentHash
    ),
    localityLbSetting: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(
      obj.localityLbSetting
    ),
    simple: obj.simple
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    baseEjectionTime: obj.baseEjectionTime,
    consecutive5xxErrors: obj.consecutive5XxErrors,
    consecutiveErrors: obj.consecutiveErrors,
    consecutiveGatewayErrors: obj.consecutiveGatewayErrors,
    consecutiveLocalOriginFailures: obj.consecutiveLocalOriginFailures,
    interval: obj.interval,
    maxEjectionPercent: obj.maxEjectionPercent,
    minHealthPercent: obj.minHealthPercent,
    splitExternalLocalOriginErrors: obj.splitExternalLocalOriginErrors
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caCertificates: obj.caCertificates,
    clientCertificate: obj.clientCertificate,
    credentialName: obj.credentialName,
    mode: obj.mode,
    privateKey: obj.privateKey,
    sni: obj.sni,
    subjectAltNames: obj.subjectAltNames?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = 'DISABLE',
  /** SIMPLE */
  SIMPLE = 'SIMPLE',
  /** MUTUAL */
  MUTUAL = 'MUTUAL',
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = 'ISTIO_MUTUAL'
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(
  obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    h2UpgradePolicy: obj.h2UpgradePolicy,
    http1MaxPendingRequests: obj.http1MaxPendingRequests,
    http2MaxRequests: obj.http2MaxRequests,
    idleTimeout: obj.idleTimeout,
    maxRequestsPerConnection: obj.maxRequestsPerConnection,
    maxRetries: obj.maxRetries,
    useClientProtocol: obj.useClientProtocol
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(
  obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTimeout: obj.connectTimeout,
    maxConnections: obj.maxConnections,
    tcpKeepalive: toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    httpCookie: toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    httpHeaderName: obj.httpHeaderName,
    httpQueryParameterName: obj.httpQueryParameterName,
    minimumRingSize: obj.minimumRingSize,
    useSourceIp: obj.useSourceIp
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    distribute: obj.distribute?.map((y) =>
      toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)
    ),
    enabled: obj.enabled,
    failover: obj.failover?.map((y) =>
      toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)
    )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = 'ROUND_ROBIN',
  /** LEAST_CONN */
  LEAST_CONN = 'LEAST_CONN',
  /** RANDOM */
  RANDOM = 'RANDOM',
  /** PASSTHROUGH */
  PASSTHROUGH = 'PASSTHROUGH'
}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    tcp: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    consistentHash: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(
      obj.consistentHash
    ),
    localityLbSetting: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(
      obj.localityLbSetting
    ),
    simple: obj.simple
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    baseEjectionTime: obj.baseEjectionTime,
    consecutive5xxErrors: obj.consecutive5XxErrors,
    consecutiveErrors: obj.consecutiveErrors,
    consecutiveGatewayErrors: obj.consecutiveGatewayErrors,
    consecutiveLocalOriginFailures: obj.consecutiveLocalOriginFailures,
    interval: obj.interval,
    maxEjectionPercent: obj.maxEjectionPercent,
    minHealthPercent: obj.minHealthPercent,
    splitExternalLocalOriginErrors: obj.splitExternalLocalOriginErrors
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caCertificates: obj.caCertificates,
    clientCertificate: obj.clientCertificate,
    credentialName: obj.credentialName,
    mode: obj.mode,
    privateKey: obj.privateKey,
    sni: obj.sni,
    subjectAltNames: obj.subjectAltNames?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = 'DISABLE',
  /** SIMPLE */
  SIMPLE = 'SIMPLE',
  /** MUTUAL */
  MUTUAL = 'MUTUAL',
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = 'ISTIO_MUTUAL'
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = 'DO_NOT_UPGRADE',
  /** UPGRADE */
  UPGRADE = 'UPGRADE'
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(
  obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    interval: obj.interval,
    probes: obj.probes,
    time: obj.time
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    path: obj.path,
    ttl: obj.ttl
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to:
      obj.to === undefined
        ? undefined
        : Object.entries(obj.to).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(
  obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to: obj.to
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    h2UpgradePolicy: obj.h2UpgradePolicy,
    http1MaxPendingRequests: obj.http1MaxPendingRequests,
    http2MaxRequests: obj.http2MaxRequests,
    idleTimeout: obj.idleTimeout,
    maxRequestsPerConnection: obj.maxRequestsPerConnection,
    maxRetries: obj.maxRetries,
    useClientProtocol: obj.useClientProtocol
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTimeout: obj.connectTimeout,
    maxConnections: obj.maxConnections,
    tcpKeepalive: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(
      obj.tcpKeepalive
    )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    httpCookie: toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(
      obj.httpCookie
    ),
    httpHeaderName: obj.httpHeaderName,
    httpQueryParameterName: obj.httpQueryParameterName,
    minimumRingSize: obj.minimumRingSize,
    useSourceIp: obj.useSourceIp
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    distribute: obj.distribute?.map((y) =>
      toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)
    ),
    enabled: obj.enabled,
    failover: obj.failover?.map((y) =>
      toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)
    )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = 'ROUND_ROBIN',
  /** LEAST_CONN */
  LEAST_CONN = 'LEAST_CONN',
  /** RANDOM */
  RANDOM = 'RANDOM',
  /** PASSTHROUGH */
  PASSTHROUGH = 'PASSTHROUGH'
}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = 'DISABLE',
  /** SIMPLE */
  SIMPLE = 'SIMPLE',
  /** MUTUAL */
  MUTUAL = 'MUTUAL',
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = 'ISTIO_MUTUAL'
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = 'DO_NOT_UPGRADE',
  /** UPGRADE */
  UPGRADE = 'UPGRADE'
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(
  obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    interval: obj.interval,
    probes: obj.probes,
    time: obj.time
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    path: obj.path,
    ttl: obj.ttl
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to:
      obj.to === undefined
        ? undefined
        : Object.entries(obj.to).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(
  obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to: obj.to
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    h2UpgradePolicy: obj.h2UpgradePolicy,
    http1MaxPendingRequests: obj.http1MaxPendingRequests,
    http2MaxRequests: obj.http2MaxRequests,
    idleTimeout: obj.idleTimeout,
    maxRequestsPerConnection: obj.maxRequestsPerConnection,
    maxRetries: obj.maxRetries,
    useClientProtocol: obj.useClientProtocol
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    connectTimeout: obj.connectTimeout,
    maxConnections: obj.maxConnections,
    tcpKeepalive: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(
      obj.tcpKeepalive
    )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    httpCookie: toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(
      obj.httpCookie
    ),
    httpHeaderName: obj.httpHeaderName,
    httpQueryParameterName: obj.httpQueryParameterName,
    minimumRingSize: obj.minimumRingSize,
    useSourceIp: obj.useSourceIp
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    distribute: obj.distribute?.map((y) =>
      toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)
    ),
    enabled: obj.enabled,
    failover: obj.failover?.map((y) =>
      toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)
    )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = 'ROUND_ROBIN',
  /** LEAST_CONN */
  LEAST_CONN = 'LEAST_CONN',
  /** RANDOM */
  RANDOM = 'RANDOM',
  /** PASSTHROUGH */
  PASSTHROUGH = 'PASSTHROUGH'
}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = 'DISABLE',
  /** SIMPLE */
  SIMPLE = 'SIMPLE',
  /** MUTUAL */
  MUTUAL = 'MUTUAL',
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = 'ISTIO_MUTUAL'
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = 'DO_NOT_UPGRADE',
  /** UPGRADE */
  UPGRADE = 'UPGRADE'
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    interval: obj.interval,
    probes: obj.probes,
    time: obj.time
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    path: obj.path,
    ttl: obj.ttl
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to:
      obj.to === undefined
        ? undefined
        : Object.entries(obj.to).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(
  obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to: obj.to
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = 'DO_NOT_UPGRADE',
  /** UPGRADE */
  UPGRADE = 'UPGRADE'
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    interval: obj.interval,
    probes: obj.probes,
    time: obj.time
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    path: obj.path,
    ttl: obj.ttl
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to:
      obj.to === undefined
        ? undefined
        : Object.entries(obj.to).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;
}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(
  obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    from: obj.from,
    to: obj.to
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 *
 *
 * @schema EnvoyFilter
 */
export class EnvoyFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'EnvoyFilter'
  };

  /**
   * Renders a Kubernetes manifest for "EnvoyFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyFilterProps = {}): any {
    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(props)
    };
  }

  /**
   * Defines a "EnvoyFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyFilterProps = {}) {
    super(scope, id, {
      ...EnvoyFilter.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(resolved)
    };
  }
}

/**
 * @schema EnvoyFilter
 */
export interface EnvoyFilterProps {
  /**
   * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
   *
   * @schema EnvoyFilter#spec
   */
  readonly spec?: EnvoyFilterSpec;

  /**
   * @schema EnvoyFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'EnvoyFilterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterProps(obj: EnvoyFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_EnvoyFilterSpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
 *
 * @schema EnvoyFilterSpec
 */
export interface EnvoyFilterSpec {
  /**
   * One or more patches with match conditions.
   *
   * @schema EnvoyFilterSpec#configPatches
   */
  readonly configPatches?: EnvoyFilterSpecConfigPatches[];

  /**
   * Priority defines the order in which patch sets are applied within a context.
   *
   * @schema EnvoyFilterSpec#priority
   */
  readonly priority?: number;

  /**
   * @schema EnvoyFilterSpec#workloadSelector
   */
  readonly workloadSelector?: EnvoyFilterSpecWorkloadSelector;
}

/**
 * Converts an object of type 'EnvoyFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpec(obj: EnvoyFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configPatches: obj.configPatches?.map((y) => toJson_EnvoyFilterSpecConfigPatches(y)),
    priority: obj.priority,
    workloadSelector: toJson_EnvoyFilterSpecWorkloadSelector(obj.workloadSelector)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatches
 */
export interface EnvoyFilterSpecConfigPatches {
  /**
   * @schema EnvoyFilterSpecConfigPatches#applyTo
   */
  readonly applyTo?: EnvoyFilterSpecConfigPatchesApplyTo;

  /**
   * Match on listener/route configuration/cluster.
   *
   * @schema EnvoyFilterSpecConfigPatches#match
   */
  readonly match?: EnvoyFilterSpecConfigPatchesMatch;

  /**
   * The patch to apply along with the operation.
   *
   * @schema EnvoyFilterSpecConfigPatches#patch
   */
  readonly patch?: EnvoyFilterSpecConfigPatchesPatch;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatches(
  obj: EnvoyFilterSpecConfigPatches | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    applyTo: obj.applyTo,
    match: toJson_EnvoyFilterSpecConfigPatchesMatch(obj.match),
    patch: toJson_EnvoyFilterSpecConfigPatchesPatch(obj.patch)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecWorkloadSelector
 */
export interface EnvoyFilterSpecWorkloadSelector {
  /**
   * @schema EnvoyFilterSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyFilterSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecWorkloadSelector(
  obj: EnvoyFilterSpecWorkloadSelector | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatchesApplyTo
 */
export enum EnvoyFilterSpecConfigPatchesApplyTo {
  /** INVALID */
  INVALID = 'INVALID',
  /** LISTENER */
  LISTENER = 'LISTENER',
  /** FILTER_CHAIN */
  FILTER_CHAIN = 'FILTER_CHAIN',
  /** NETWORK_FILTER */
  NETWORK_FILTER = 'NETWORK_FILTER',
  /** HTTP_FILTER */
  HTTP_FILTER = 'HTTP_FILTER',
  /** ROUTE_CONFIGURATION */
  ROUTE_CONFIGURATION = 'ROUTE_CONFIGURATION',
  /** VIRTUAL_HOST */
  VIRTUAL_HOST = 'VIRTUAL_HOST',
  /** HTTP_ROUTE */
  HTTP_ROUTE = 'HTTP_ROUTE',
  /** CLUSTER */
  CLUSTER = 'CLUSTER',
  /** EXTENSION_CONFIG */
  EXTENSION_CONFIG = 'EXTENSION_CONFIG',
  /** BOOTSTRAP */
  BOOTSTRAP = 'BOOTSTRAP'
}

/**
 * Match on listener/route configuration/cluster.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatch
 */
export interface EnvoyFilterSpecConfigPatchesMatch {
  /**
   * Match on envoy cluster attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#cluster
   */
  readonly cluster?: EnvoyFilterSpecConfigPatchesMatchCluster;

  /**
   * The specific config generation context to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#context
   */
  readonly context?: EnvoyFilterSpecConfigPatchesMatchContext;

  /**
   * Match on envoy listener attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#listener
   */
  readonly listener?: EnvoyFilterSpecConfigPatchesMatchListener;

  /**
   * Match on properties associated with a proxy.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#proxy
   */
  readonly proxy?: EnvoyFilterSpecConfigPatchesMatchProxy;

  /**
   * Match on envoy HTTP route configuration attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#routeConfiguration
   */
  readonly routeConfiguration?: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatch(
  obj: EnvoyFilterSpecConfigPatchesMatch | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cluster: toJson_EnvoyFilterSpecConfigPatchesMatchCluster(obj.cluster),
    context: obj.context,
    listener: toJson_EnvoyFilterSpecConfigPatchesMatchListener(obj.listener),
    proxy: toJson_EnvoyFilterSpecConfigPatchesMatchProxy(obj.proxy),
    routeConfiguration: toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(obj.routeConfiguration)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The patch to apply along with the operation.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatch
 */
export interface EnvoyFilterSpecConfigPatchesPatch {
  /**
   * Determines the filter insertion order.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#filterClass
   */
  readonly filterClass?: EnvoyFilterSpecConfigPatchesPatchFilterClass;

  /**
   * Determines how the patch should be applied.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#operation
   */
  readonly operation?: EnvoyFilterSpecConfigPatchesPatchOperation;

  /**
   * The JSON config of the object being patched.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesPatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesPatch(
  obj: EnvoyFilterSpecConfigPatchesPatch | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    filterClass: obj.filterClass,
    operation: obj.operation,
    value: obj.value
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on envoy cluster attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchCluster
 */
export interface EnvoyFilterSpecConfigPatchesMatchCluster {
  /**
   * The exact name of the cluster to match.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#name
   */
  readonly name?: string;

  /**
   * The service port for which this cluster was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#portNumber
   */
  readonly portNumber?: number;

  /**
   * The fully qualified service name for this cluster.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#service
   */
  readonly service?: string;

  /**
   * The subset associated with the service.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchCluster(
  obj: EnvoyFilterSpecConfigPatchesMatchCluster | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    portNumber: obj.portNumber,
    service: obj.service,
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specific config generation context to match on.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchContext
 */
export enum EnvoyFilterSpecConfigPatchesMatchContext {
  /** ANY */
  ANY = 'ANY',
  /** SIDECAR_INBOUND */
  SIDECAR_INBOUND = 'SIDECAR_INBOUND',
  /** SIDECAR_OUTBOUND */
  SIDECAR_OUTBOUND = 'SIDECAR_OUTBOUND',
  /** GATEWAY */
  GATEWAY = 'GATEWAY'
}

/**
 * Match on envoy listener attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListener
 */
export interface EnvoyFilterSpecConfigPatchesMatchListener {
  /**
   * Match a specific filter chain in a listener.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#filterChain
   */
  readonly filterChain?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain;

  /**
   * Match a specific listener by its name.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#name
   */
  readonly name?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portName
   */
  readonly portName?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portNumber
   */
  readonly portNumber?: number;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListener(
  obj: EnvoyFilterSpecConfigPatchesMatchListener | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    filterChain: toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(obj.filterChain),
    name: obj.name,
    portName: obj.portName,
    portNumber: obj.portNumber
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on properties associated with a proxy.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchProxy
 */
export interface EnvoyFilterSpecConfigPatchesMatchProxy {
  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#proxyVersion
   */
  readonly proxyVersion?: string;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchProxy(
  obj: EnvoyFilterSpecConfigPatchesMatchProxy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata:
      obj.metadata === undefined
        ? undefined
        : Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    proxyVersion: obj.proxyVersion
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match on envoy HTTP route configuration attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfiguration {
  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#gateway
   */
  readonly gateway?: string;

  /**
   * Route configuration name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#name
   */
  readonly name?: string;

  /**
   * Applicable only for GATEWAY context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portName
   */
  readonly portName?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portNumber
   */
  readonly portNumber?: number;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#vhost
   */
  readonly vhost?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(
  obj: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gateway: obj.gateway,
    name: obj.name,
    portName: obj.portName,
    portNumber: obj.portNumber,
    vhost: toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(obj.vhost)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines the filter insertion order.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchFilterClass
 */
export enum EnvoyFilterSpecConfigPatchesPatchFilterClass {
  /** UNSPECIFIED */
  UNSPECIFIED = 'UNSPECIFIED',
  /** AUTHN */
  AUTHN = 'AUTHN',
  /** AUTHZ */
  AUTHZ = 'AUTHZ',
  /** STATS */
  STATS = 'STATS'
}

/**
 * Determines how the patch should be applied.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchOperation
 */
export enum EnvoyFilterSpecConfigPatchesPatchOperation {
  /** INVALID */
  INVALID = 'INVALID',
  /** MERGE */
  MERGE = 'MERGE',
  /** ADD */
  ADD = 'ADD',
  /** REMOVE */
  REMOVE = 'REMOVE',
  /** INSERT_BEFORE */
  INSERT_BEFORE = 'INSERT_BEFORE',
  /** INSERT_AFTER */
  INSERT_AFTER = 'INSERT_AFTER',
  /** INSERT_FIRST */
  INSERT_FIRST = 'INSERT_FIRST',
  /** REPLACE */
  REPLACE = 'REPLACE'
}

/**
 * Match a specific filter chain in a listener.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChain {
  /**
   * Applies only to sidecars.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#applicationProtocols
   */
  readonly applicationProtocols?: string;

  /**
   * The destination_port value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#destinationPort
   */
  readonly destinationPort?: number;

  /**
   * The name of a specific filter to apply the patch to.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#filter
   */
  readonly filter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter;

  /**
   * The name assigned to the filter chain.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#name
   */
  readonly name?: string;

  /**
   * The SNI value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#sni
   */
  readonly sni?: string;

  /**
   * Applies only to `SIDECAR_INBOUND` context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#transportProtocol
   */
  readonly transportProtocol?: string;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(
  obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    applicationProtocols: obj.applicationProtocols,
    destinationPort: obj.destinationPort,
    filter: toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(obj.filter),
    name: obj.name,
    sni: obj.sni,
    transportProtocol: obj.transportProtocol
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost {
  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#name
   */
  readonly name?: string;

  /**
   * Match a specific route within the virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#route
   */
  readonly route?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(
  obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    route: toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(obj.route)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of a specific filter to apply the patch to.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#name
   */
  readonly name?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#subFilter
   */
  readonly subFilter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(
  obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    subFilter: toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(obj.subFilter)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match a specific route within the virtual host.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute {
  /**
   * Match a route with specific action type.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#action
   */
  readonly action?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(
  obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    action: obj.action,
    name: obj.name
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(
  obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match a route with specific action type.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction
 */
export enum EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction {
  /** ANY */
  ANY = 'ANY',
  /** ROUTE */
  ROUTE = 'ROUTE',
  /** REDIRECT */
  REDIRECT = 'REDIRECT',
  /** DIRECT_RESPONSE */
  DIRECT_RESPONSE = 'DIRECT_RESPONSE'
}

/**
 *
 *
 * @schema Gateway
 */
export class Gateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Gateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'Gateway'
  };

  /**
   * Renders a Kubernetes manifest for "Gateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayProps = {}): any {
    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(props)
    };
  }

  /**
   * Defines a "Gateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayProps = {}) {
    super(scope, id, {
      ...Gateway.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(resolved)
    };
  }
}

/**
 * @schema Gateway
 */
export interface GatewayProps {
  /**
   * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
   *
   * @schema Gateway#spec
   */
  readonly spec?: GatewaySpec;

  /**
   * @schema Gateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'GatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayProps(obj: GatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_GatewaySpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
 *
 * @schema GatewaySpec
 */
export interface GatewaySpec {
  /**
   * @schema GatewaySpec#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * A list of server specifications.
   *
   * @schema GatewaySpec#servers
   */
  readonly servers?: GatewaySpecServers[];
}

/**
 * Converts an object of type 'GatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpec(obj: GatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    selector:
      obj.selector === undefined
        ? undefined
        : Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    servers: obj.servers?.map((y) => toJson_GatewaySpecServers(y))
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewaySpecServers
 */
export interface GatewaySpecServers {
  /**
   * @schema GatewaySpecServers#bind
   */
  readonly bind?: string;

  /**
   * @schema GatewaySpecServers#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * One or more hosts exposed by this gateway.
   *
   * @schema GatewaySpecServers#hosts
   */
  readonly hosts?: string[];

  /**
   * An optional name of the server, when set must be unique across all servers.
   *
   * @schema GatewaySpecServers#name
   */
  readonly name?: string;

  /**
   * @schema GatewaySpecServers#port
   */
  readonly port?: GatewaySpecServersPort;

  /**
   * Set of TLS related options that govern the server's behavior.
   *
   * @schema GatewaySpecServers#tls
   */
  readonly tls?: GatewaySpecServersTls;
}

/**
 * Converts an object of type 'GatewaySpecServers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecServers(obj: GatewaySpecServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bind: obj.bind,
    defaultEndpoint: obj.defaultEndpoint,
    hosts: obj.hosts?.map((y) => y),
    name: obj.name,
    port: toJson_GatewaySpecServersPort(obj.port),
    tls: toJson_GatewaySpecServersTls(obj.tls)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GatewaySpecServersPort
 */
export interface GatewaySpecServersPort {
  /**
   * Label assigned to the port.
   *
   * @schema GatewaySpecServersPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema GatewaySpecServersPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema GatewaySpecServersPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema GatewaySpecServersPort#targetPort
   */
  readonly targetPort?: number;
}

/**
 * Converts an object of type 'GatewaySpecServersPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecServersPort(
  obj: GatewaySpecServersPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    number: obj.number,
    protocol: obj.protocol,
    targetPort: obj.targetPort
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of TLS related options that govern the server's behavior.
 *
 * @schema GatewaySpecServersTls
 */
export interface GatewaySpecServersTls {
  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema GatewaySpecServersTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema GatewaySpecServersTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * @schema GatewaySpecServersTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema GatewaySpecServersTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * @schema GatewaySpecServersTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: GatewaySpecServersTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * @schema GatewaySpecServersTls#minProtocolVersion
   */
  readonly minProtocolVersion?: GatewaySpecServersTlsMinProtocolVersion;

  /**
   * @schema GatewaySpecServersTls#mode
   */
  readonly mode?: GatewaySpecServersTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * @schema GatewaySpecServersTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * @schema GatewaySpecServersTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * @schema GatewaySpecServersTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];
}

/**
 * Converts an object of type 'GatewaySpecServersTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewaySpecServersTls(obj: GatewaySpecServersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caCertificates: obj.caCertificates,
    cipherSuites: obj.cipherSuites?.map((y) => y),
    credentialName: obj.credentialName,
    httpsRedirect: obj.httpsRedirect,
    maxProtocolVersion: obj.maxProtocolVersion,
    minProtocolVersion: obj.minProtocolVersion,
    mode: obj.mode,
    privateKey: obj.privateKey,
    serverCertificate: obj.serverCertificate,
    subjectAltNames: obj.subjectAltNames?.map((y) => y),
    verifyCertificateHash: obj.verifyCertificateHash?.map((y) => y),
    verifyCertificateSpki: obj.verifyCertificateSpki?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * @schema GatewaySpecServersTlsMaxProtocolVersion
 */
export enum GatewaySpecServersTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_AUTO = 'TLS_AUTO',
  /** TLSV1_0 */
  TLSV1_0 = 'TLSV1_0',
  /** TLSV1_1 */
  TLSV1_1 = 'TLSV1_1',
  /** TLSV1_2 */
  TLSV1_2 = 'TLSV1_2',
  /** TLSV1_3 */
  TLSV1_3 = 'TLSV1_3'
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * @schema GatewaySpecServersTlsMinProtocolVersion
 */
export enum GatewaySpecServersTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_AUTO = 'TLS_AUTO',
  /** TLSV1_0 */
  TLSV1_0 = 'TLSV1_0',
  /** TLSV1_1 */
  TLSV1_1 = 'TLSV1_1',
  /** TLSV1_2 */
  TLSV1_2 = 'TLSV1_2',
  /** TLSV1_3 */
  TLSV1_3 = 'TLSV1_3'
}

/**
 * @schema GatewaySpecServersTlsMode
 */
export enum GatewaySpecServersTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = 'PASSTHROUGH',
  /** SIMPLE */
  SIMPLE = 'SIMPLE',
  /** MUTUAL */
  MUTUAL = 'MUTUAL',
  /** AUTO_PASSTHROUGH */
  AUTO_PASSTHROUGH = 'AUTO_PASSTHROUGH',
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = 'ISTIO_MUTUAL'
}

/**
 *
 *
 * @schema ServiceEntry
 */
export class ServiceEntry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceEntry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'ServiceEntry'
  };

  /**
   * Renders a Kubernetes manifest for "ServiceEntry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceEntryProps = {}): any {
    return {
      ...ServiceEntry.GVK,
      ...toJson_ServiceEntryProps(props)
    };
  }

  /**
   * Defines a "ServiceEntry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceEntryProps = {}) {
    super(scope, id, {
      ...ServiceEntry.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceEntry.GVK,
      ...toJson_ServiceEntryProps(resolved)
    };
  }
}

/**
 * @schema ServiceEntry
 */
export interface ServiceEntryProps {
  /**
   * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
   *
   * @schema ServiceEntry#spec
   */
  readonly spec?: ServiceEntrySpec;

  /**
   * @schema ServiceEntry#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'ServiceEntryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceEntryProps(obj: ServiceEntryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_ServiceEntrySpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
 *
 * @schema ServiceEntrySpec
 */
export interface ServiceEntrySpec {
  /**
   * The virtual IP addresses associated with the service.
   *
   * @schema ServiceEntrySpec#addresses
   */
  readonly addresses?: string[];

  /**
   * One or more endpoints associated with the service.
   *
   * @schema ServiceEntrySpec#endpoints
   */
  readonly endpoints?: ServiceEntrySpecEndpoints[];

  /**
   * A list of namespaces to which this service is exported.
   *
   * @schema ServiceEntrySpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The hosts associated with the ServiceEntry.
   *
   * @schema ServiceEntrySpec#hosts
   */
  readonly hosts?: string[];

  /**
   * @schema ServiceEntrySpec#location
   */
  readonly location?: ServiceEntrySpecLocation;

  /**
   * The ports associated with the external service.
   *
   * @schema ServiceEntrySpec#ports
   */
  readonly ports?: ServiceEntrySpecPorts[];

  /**
   * Service discovery mode for the hosts.
   *
   * @schema ServiceEntrySpec#resolution
   */
  readonly resolution?: ServiceEntrySpecResolution;

  /**
   * @schema ServiceEntrySpec#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Applicable only for MESH_INTERNAL services.
   *
   * @schema ServiceEntrySpec#workloadSelector
   */
  readonly workloadSelector?: ServiceEntrySpecWorkloadSelector;
}

/**
 * Converts an object of type 'ServiceEntrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceEntrySpec(obj: ServiceEntrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    addresses: obj.addresses?.map((y) => y),
    endpoints: obj.endpoints?.map((y) => toJson_ServiceEntrySpecEndpoints(y)),
    exportTo: obj.exportTo?.map((y) => y),
    hosts: obj.hosts?.map((y) => y),
    location: obj.location,
    ports: obj.ports?.map((y) => toJson_ServiceEntrySpecPorts(y)),
    resolution: obj.resolution,
    subjectAltNames: obj.subjectAltNames?.map((y) => y),
    workloadSelector: toJson_ServiceEntrySpecWorkloadSelector(obj.workloadSelector)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceEntrySpecEndpoints
 */
export interface ServiceEntrySpecEndpoints {
  /**
   * @schema ServiceEntrySpecEndpoints#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#locality
   */
  readonly locality?: string;

  /**
   * @schema ServiceEntrySpecEndpoints#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * @schema ServiceEntrySpecEndpoints#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'ServiceEntrySpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceEntrySpecEndpoints(
  obj: ServiceEntrySpecEndpoints | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    address: obj.address,
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    locality: obj.locality,
    network: obj.network,
    ports:
      obj.ports === undefined
        ? undefined
        : Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    serviceAccount: obj.serviceAccount,
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceEntrySpecLocation
 */
export enum ServiceEntrySpecLocation {
  /** MESH_EXTERNAL */
  MESH_EXTERNAL = 'MESH_EXTERNAL',
  /** MESH_INTERNAL */
  MESH_INTERNAL = 'MESH_INTERNAL'
}

/**
 * @schema ServiceEntrySpecPorts
 */
export interface ServiceEntrySpecPorts {
  /**
   * Label assigned to the port.
   *
   * @schema ServiceEntrySpecPorts#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema ServiceEntrySpecPorts#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema ServiceEntrySpecPorts#protocol
   */
  readonly protocol?: string;

  /**
   * @schema ServiceEntrySpecPorts#targetPort
   */
  readonly targetPort?: number;
}

/**
 * Converts an object of type 'ServiceEntrySpecPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceEntrySpecPorts(obj: ServiceEntrySpecPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    number: obj.number,
    protocol: obj.protocol,
    targetPort: obj.targetPort
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service discovery mode for the hosts.
 *
 * @schema ServiceEntrySpecResolution
 */
export enum ServiceEntrySpecResolution {
  /** NONE */
  NONE = 'NONE',
  /** STATIC */
  STATIC = 'STATIC',
  /** DNS */
  DNS = 'DNS'
}

/**
 * Applicable only for MESH_INTERNAL services.
 *
 * @schema ServiceEntrySpecWorkloadSelector
 */
export interface ServiceEntrySpecWorkloadSelector {
  /**
   * @schema ServiceEntrySpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ServiceEntrySpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceEntrySpecWorkloadSelector(
  obj: ServiceEntrySpecWorkloadSelector | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 *
 *
 * @schema Sidecar
 */
export class Sidecar extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Sidecar"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'Sidecar'
  };

  /**
   * Renders a Kubernetes manifest for "Sidecar".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarProps = {}): any {
    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(props)
    };
  }

  /**
   * Defines a "Sidecar" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarProps = {}) {
    super(scope, id, {
      ...Sidecar.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(resolved)
    };
  }
}

/**
 * @schema Sidecar
 */
export interface SidecarProps {
  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema Sidecar#spec
   */
  readonly spec?: SidecarSpec;

  /**
   * @schema Sidecar#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'SidecarProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarProps(obj: SidecarProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_SidecarSpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarSpec
 */
export interface SidecarSpec {
  /**
   * @schema SidecarSpec#egress
   */
  readonly egress?: SidecarSpecEgress[];

  /**
   * @schema SidecarSpec#ingress
   */
  readonly ingress?: SidecarSpecIngress[];

  /**
   * Configuration for the outbound traffic policy.
   *
   * @schema SidecarSpec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarSpecOutboundTrafficPolicy;

  /**
   * @schema SidecarSpec#workloadSelector
   */
  readonly workloadSelector?: SidecarSpecWorkloadSelector;
}

/**
 * Converts an object of type 'SidecarSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpec(obj: SidecarSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    egress: obj.egress?.map((y) => toJson_SidecarSpecEgress(y)),
    ingress: obj.ingress?.map((y) => toJson_SidecarSpecIngress(y)),
    outboundTrafficPolicy: toJson_SidecarSpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    workloadSelector: toJson_SidecarSpecWorkloadSelector(obj.workloadSelector)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecEgress
 */
export interface SidecarSpecEgress {
  /**
   * @schema SidecarSpecEgress#bind
   */
  readonly bind?: string;

  /**
   * @schema SidecarSpecEgress#captureMode
   */
  readonly captureMode?: SidecarSpecEgressCaptureMode;

  /**
   * @schema SidecarSpecEgress#hosts
   */
  readonly hosts?: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecEgress#port
   */
  readonly port?: SidecarSpecEgressPort;
}

/**
 * Converts an object of type 'SidecarSpecEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecEgress(obj: SidecarSpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bind: obj.bind,
    captureMode: obj.captureMode,
    hosts: obj.hosts?.map((y) => y),
    port: toJson_SidecarSpecEgressPort(obj.port)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecIngress
 */
export interface SidecarSpecIngress {
  /**
   * The IP to which the listener should be bound.
   *
   * @schema SidecarSpecIngress#bind
   */
  readonly bind?: string;

  /**
   * @schema SidecarSpecIngress#captureMode
   */
  readonly captureMode?: SidecarSpecIngressCaptureMode;

  /**
   * @schema SidecarSpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecIngress#port
   */
  readonly port?: SidecarSpecIngressPort;
}

/**
 * Converts an object of type 'SidecarSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngress(obj: SidecarSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bind: obj.bind,
    captureMode: obj.captureMode,
    defaultEndpoint: obj.defaultEndpoint,
    port: toJson_SidecarSpecIngressPort(obj.port)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for the outbound traffic policy.
 *
 * @schema SidecarSpecOutboundTrafficPolicy
 */
export interface SidecarSpecOutboundTrafficPolicy {
  /**
   * @schema SidecarSpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarSpecOutboundTrafficPolicyEgressProxy;

  /**
   * @schema SidecarSpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarSpecOutboundTrafficPolicyMode;
}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicy(
  obj: SidecarSpecOutboundTrafficPolicy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    egressProxy: toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    mode: obj.mode
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecWorkloadSelector
 */
export interface SidecarSpecWorkloadSelector {
  /**
   * @schema SidecarSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'SidecarSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecWorkloadSelector(
  obj: SidecarSpecWorkloadSelector | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecEgressCaptureMode
 */
export enum SidecarSpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** IPTABLES */
  IPTABLES = 'IPTABLES',
  /** NONE */
  NONE = 'NONE'
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecEgressPort
 */
export interface SidecarSpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecEgressPort#targetPort
   */
  readonly targetPort?: number;
}

/**
 * Converts an object of type 'SidecarSpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecEgressPort(obj: SidecarSpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    number: obj.number,
    protocol: obj.protocol,
    targetPort: obj.targetPort
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecIngressCaptureMode
 */
export enum SidecarSpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = 'DEFAULT',
  /** IPTABLES */
  IPTABLES = 'IPTABLES',
  /** NONE */
  NONE = 'NONE'
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecIngressPort
 */
export interface SidecarSpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecIngressPort#targetPort
   */
  readonly targetPort?: number;
}

/**
 * Converts an object of type 'SidecarSpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecIngressPort(
  obj: SidecarSpecIngressPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    number: obj.number,
    protocol: obj.protocol,
    targetPort: obj.targetPort
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host?: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarSpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(
  obj: SidecarSpecOutboundTrafficPolicyEgressProxy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SidecarSpecOutboundTrafficPolicyMode
 */
export enum SidecarSpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_ONLY = 'REGISTRY_ONLY',
  /** ALLOW_ANY */
  ALLOW_ANY = 'ALLOW_ANY'
}

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(
  obj: SidecarSpecOutboundTrafficPolicyEgressProxyPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 *
 *
 * @schema VirtualService
 */
export class VirtualService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'VirtualService'
  };

  /**
   * Renders a Kubernetes manifest for "VirtualService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceProps = {}): any {
    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(props)
    };
  }

  /**
   * Defines a "VirtualService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceProps = {}) {
    super(scope, id, {
      ...VirtualService.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(resolved)
    };
  }
}

/**
 * @schema VirtualService
 */
export interface VirtualServiceProps {
  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualService#spec
   */
  readonly spec?: VirtualServiceSpec;

  /**
   * @schema VirtualService#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'VirtualServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceProps(obj: VirtualServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_VirtualServiceSpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceSpec
 */
export interface VirtualServiceSpec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceSpec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceSpec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceSpec#http
   */
  readonly http?: VirtualServiceSpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceSpec#tcp
   */
  readonly tcp?: VirtualServiceSpecTcp[];

  /**
   * @schema VirtualServiceSpec#tls
   */
  readonly tls?: VirtualServiceSpecTls[];
}

/**
 * Converts an object of type 'VirtualServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpec(obj: VirtualServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exportTo: obj.exportTo?.map((y) => y),
    gateways: obj.gateways?.map((y) => y),
    hosts: obj.hosts?.map((y) => y),
    http: obj.http?.map((y) => toJson_VirtualServiceSpecHttp(y)),
    tcp: obj.tcp?.map((y) => toJson_VirtualServiceSpecTcp(y)),
    tls: obj.tls?.map((y) => toJson_VirtualServiceSpecTls(y))
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttp
 */
export interface VirtualServiceSpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceSpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceSpecHttpCorsPolicy;

  /**
   * @schema VirtualServiceSpecHttp#delegate
   */
  readonly delegate?: VirtualServiceSpecHttpDelegate;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceSpecHttp#fault
   */
  readonly fault?: VirtualServiceSpecHttpFault;

  /**
   * @schema VirtualServiceSpecHttp#headers
   */
  readonly headers?: VirtualServiceSpecHttpHeaders;

  /**
   * @schema VirtualServiceSpecHttp#match
   */
  readonly match?: VirtualServiceSpecHttpMatch[];

  /**
   * @schema VirtualServiceSpecHttp#mirror
   */
  readonly mirror?: VirtualServiceSpecHttpMirror;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceSpecHttp#mirrorPercent
   */
  readonly mirrorPercent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceSpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceSpecHttpMirrorPercentage;

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceSpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#redirect
   */
  readonly redirect?: VirtualServiceSpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceSpecHttp#retries
   */
  readonly retries?: VirtualServiceSpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceSpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceSpecHttpRewrite;

  /**
   * A HTTP rule can either redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#route
   */
  readonly route?: VirtualServiceSpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceSpecHttp#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttp(
  obj: VirtualServiceSpecHttp | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    corsPolicy: toJson_VirtualServiceSpecHttpCorsPolicy(obj.corsPolicy),
    delegate: toJson_VirtualServiceSpecHttpDelegate(obj.delegate),
    fault: toJson_VirtualServiceSpecHttpFault(obj.fault),
    headers: toJson_VirtualServiceSpecHttpHeaders(obj.headers),
    match: obj.match?.map((y) => toJson_VirtualServiceSpecHttpMatch(y)),
    mirror: toJson_VirtualServiceSpecHttpMirror(obj.mirror),
    mirror_percent: obj.mirrorPercent,
    mirrorPercent: obj.mirrorPercent,
    mirrorPercentage: toJson_VirtualServiceSpecHttpMirrorPercentage(obj.mirrorPercentage),
    name: obj.name,
    redirect: toJson_VirtualServiceSpecHttpRedirect(obj.redirect),
    retries: toJson_VirtualServiceSpecHttpRetries(obj.retries),
    rewrite: toJson_VirtualServiceSpecHttpRewrite(obj.rewrite),
    route: obj.route?.map((y) => toJson_VirtualServiceSpecHttpRoute(y)),
    timeout: obj.timeout
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcp
 */
export interface VirtualServiceSpecTcp {
  /**
   * @schema VirtualServiceSpecTcp#match
   */
  readonly match?: VirtualServiceSpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTcp#route
   */
  readonly route?: VirtualServiceSpecTcpRoute[];
}

/**
 * Converts an object of type 'VirtualServiceSpecTcp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcp(obj: VirtualServiceSpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    match: obj.match?.map((y) => toJson_VirtualServiceSpecTcpMatch(y)),
    route: obj.route?.map((y) => toJson_VirtualServiceSpecTcpRoute(y))
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTls
 */
export interface VirtualServiceSpecTls {
  /**
   * @schema VirtualServiceSpecTls#match
   */
  readonly match?: VirtualServiceSpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTls#route
   */
  readonly route?: VirtualServiceSpecTlsRoute[];
}

/**
 * Converts an object of type 'VirtualServiceSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTls(obj: VirtualServiceSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    match: obj.match?.map((y) => toJson_VirtualServiceSpecTlsMatch(y)),
    route: obj.route?.map((y) => toJson_VirtualServiceSpecTlsRoute(y))
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceSpecHttpCorsPolicy
 */
export interface VirtualServiceSpecHttpCorsPolicy {
  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * The list of origins that are allowed to perform CORS requests.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceSpecHttpCorsPolicyAllowOrigins[];

  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicy(
  obj: VirtualServiceSpecHttpCorsPolicy | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowCredentials: obj.allowCredentials,
    allowHeaders: obj.allowHeaders?.map((y) => y),
    allowMethods: obj.allowMethods?.map((y) => y),
    allowOrigin: obj.allowOrigin?.map((y) => y),
    allowOrigins: obj.allowOrigins?.map((y) => toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(y)),
    exposeHeaders: obj.exposeHeaders?.map((y) => y),
    maxAge: obj.maxAge
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpDelegate
 */
export interface VirtualServiceSpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceSpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceSpecHttpDelegate#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpDelegate(
  obj: VirtualServiceSpecHttpDelegate | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    namespace: obj.namespace
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceSpecHttpFault
 */
export interface VirtualServiceSpecHttpFault {
  /**
   * @schema VirtualServiceSpecHttpFault#abort
   */
  readonly abort?: VirtualServiceSpecHttpFaultAbort;

  /**
   * @schema VirtualServiceSpecHttpFault#delay
   */
  readonly delay?: VirtualServiceSpecHttpFaultDelay;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFault(
  obj: VirtualServiceSpecHttpFault | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    abort: toJson_VirtualServiceSpecHttpFaultAbort(obj.abort),
    delay: toJson_VirtualServiceSpecHttpFaultDelay(obj.delay)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeaders
 */
export interface VirtualServiceSpecHttpHeaders {
  /**
   * @schema VirtualServiceSpecHttpHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpHeadersResponse;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeaders(
  obj: VirtualServiceSpecHttpHeaders | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    request: toJson_VirtualServiceSpecHttpHeadersRequest(obj.request),
    response: toJson_VirtualServiceSpecHttpHeadersResponse(obj.response)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatch
 */
export interface VirtualServiceSpecHttpMatch {
  /**
   * @schema VirtualServiceSpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceSpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * @schema VirtualServiceSpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceSpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceSpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * @schema VirtualServiceSpecHttpMatch#method
   */
  readonly method?: VirtualServiceSpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceSpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceSpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceSpecHttpMatchQueryParams };

  /**
   * @schema VirtualServiceSpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceSpecHttpMatchScheme;

  /**
   * @schema VirtualServiceSpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceSpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceSpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceSpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceSpecHttpMatchWithoutHeaders };
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatch(
  obj: VirtualServiceSpecHttpMatch | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authority: toJson_VirtualServiceSpecHttpMatchAuthority(obj.authority),
    gateways: obj.gateways?.map((y) => y),
    headers:
      obj.headers === undefined
        ? undefined
        : Object.entries(obj.headers).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchHeaders(i[1]) }),
            {}
          ),
    ignoreUriCase: obj.ignoreUriCase,
    method: toJson_VirtualServiceSpecHttpMatchMethod(obj.method),
    name: obj.name,
    port: obj.port,
    queryParams:
      obj.queryParams === undefined
        ? undefined
        : Object.entries(obj.queryParams).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchQueryParams(i[1]) }),
            {}
          ),
    scheme: toJson_VirtualServiceSpecHttpMatchScheme(obj.scheme),
    sourceLabels:
      obj.sourceLabels === undefined
        ? undefined
        : Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    sourceNamespace: obj.sourceNamespace,
    uri: toJson_VirtualServiceSpecHttpMatchUri(obj.uri),
    withoutHeaders:
      obj.withoutHeaders === undefined
        ? undefined
        : Object.entries(obj.withoutHeaders).reduce(
            (r, i) =>
              i[1] === undefined ? r : { ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchWithoutHeaders(i[1]) },
            {}
          )
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMirror
 */
export interface VirtualServiceSpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpMirror#host
   */
  readonly host?: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMirror#port
   */
  readonly port?: VirtualServiceSpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpMirror#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirror(
  obj: VirtualServiceSpecHttpMirror | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: toJson_VirtualServiceSpecHttpMirrorPort(obj.port),
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceSpecHttpMirrorPercentage
 */
export interface VirtualServiceSpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceSpecHttpMirrorPercentage#value
   */
  readonly value?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPercentage(
  obj: VirtualServiceSpecHttpMirrorPercentage | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    value: obj.value
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A HTTP rule can either redirect or forward (default) traffic.
 *
 * @schema VirtualServiceSpecHttpRedirect
 */
export interface VirtualServiceSpecHttpRedirect {
  /**
   * @schema VirtualServiceSpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * @schema VirtualServiceSpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * @schema VirtualServiceSpecHttpRedirect#uri
   */
  readonly uri?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRedirect(
  obj: VirtualServiceSpecHttpRedirect | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authority: obj.authority,
    redirectCode: obj.redirectCode,
    uri: obj.uri
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceSpecHttpRetries
 */
export interface VirtualServiceSpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceSpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceSpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceSpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceSpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRetries(
  obj: VirtualServiceSpecHttpRetries | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    attempts: obj.attempts,
    perTryTimeout: obj.perTryTimeout,
    retryOn: obj.retryOn,
    retryRemoteLocalities: obj.retryRemoteLocalities
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceSpecHttpRewrite
 */
export interface VirtualServiceSpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceSpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * @schema VirtualServiceSpecHttpRewrite#uri
   */
  readonly uri?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRewrite(
  obj: VirtualServiceSpecHttpRewrite | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    authority: obj.authority,
    uri: obj.uri
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRoute
 */
export interface VirtualServiceSpecHttpRoute {
  /**
   * @schema VirtualServiceSpecHttpRoute#destination
   */
  readonly destination?: VirtualServiceSpecHttpRouteDestination;

  /**
   * @schema VirtualServiceSpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceSpecHttpRouteHeaders;

  /**
   * @schema VirtualServiceSpecHttpRoute#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRoute(
  obj: VirtualServiceSpecHttpRoute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    destination: toJson_VirtualServiceSpecHttpRouteDestination(obj.destination),
    headers: toJson_VirtualServiceSpecHttpRouteHeaders(obj.headers),
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcpMatch
 */
export interface VirtualServiceSpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * @schema VirtualServiceSpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * IPv4 or IPv6 ip address of source with optional subnet.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpMatch(
  obj: VirtualServiceSpecTcpMatch | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    destinationSubnets: obj.destinationSubnets?.map((y) => y),
    gateways: obj.gateways?.map((y) => y),
    port: obj.port,
    sourceLabels:
      obj.sourceLabels === undefined
        ? undefined
        : Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    sourceNamespace: obj.sourceNamespace,
    sourceSubnet: obj.sourceSubnet
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcpRoute
 */
export interface VirtualServiceSpecTcpRoute {
  /**
   * @schema VirtualServiceSpecTcpRoute#destination
   */
  readonly destination?: VirtualServiceSpecTcpRouteDestination;

  /**
   * @schema VirtualServiceSpecTcpRoute#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRoute(
  obj: VirtualServiceSpecTcpRoute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    destination: toJson_VirtualServiceSpecTcpRouteDestination(obj.destination),
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTlsMatch
 */
export interface VirtualServiceSpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceSpecTlsMatch#sniHosts
   */
  readonly sniHosts?: string[];

  /**
   * @schema VirtualServiceSpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsMatch(
  obj: VirtualServiceSpecTlsMatch | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    destinationSubnets: obj.destinationSubnets?.map((y) => y),
    gateways: obj.gateways?.map((y) => y),
    port: obj.port,
    sniHosts: obj.sniHosts?.map((y) => y),
    sourceLabels:
      obj.sourceLabels === undefined
        ? undefined
        : Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    sourceNamespace: obj.sourceNamespace
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTlsRoute
 */
export interface VirtualServiceSpecTlsRoute {
  /**
   * @schema VirtualServiceSpecTlsRoute#destination
   */
  readonly destination?: VirtualServiceSpecTlsRouteDestination;

  /**
   * @schema VirtualServiceSpecTlsRoute#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRoute(
  obj: VirtualServiceSpecTlsRoute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    destination: toJson_VirtualServiceSpecTlsRouteDestination(obj.destination),
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceSpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(
  obj: VirtualServiceSpecHttpCorsPolicyAllowOrigins | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpFaultAbort
 */
export interface VirtualServiceSpecHttpFaultAbort {
  /**
   * @schema VirtualServiceSpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceSpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultAbortPercentage;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbort(
  obj: VirtualServiceSpecHttpFaultAbort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    grpcStatus: obj.grpcStatus,
    http2Error: obj.http2Error,
    httpStatus: obj.httpStatus,
    percentage: toJson_VirtualServiceSpecHttpFaultAbortPercentage(obj.percentage)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpFaultDelay
 */
export interface VirtualServiceSpecHttpFaultDelay {
  /**
   * @schema VirtualServiceSpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultDelayPercentage;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelay(
  obj: VirtualServiceSpecHttpFaultDelay | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exponentialDelay: obj.exponentialDelay,
    fixedDelay: obj.fixedDelay,
    percent: obj.percent,
    percentage: toJson_VirtualServiceSpecHttpFaultDelayPercentage(obj.percentage)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersRequest
 */
export interface VirtualServiceSpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeadersRequest(
  obj: VirtualServiceSpecHttpHeadersRequest | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add:
      obj.add === undefined
        ? undefined
        : Object.entries(obj.add).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    remove: obj.remove?.map((y) => y),
    set:
      obj.set === undefined
        ? undefined
        : Object.entries(obj.set).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersResponse
 */
export interface VirtualServiceSpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpHeadersResponse(
  obj: VirtualServiceSpecHttpHeadersResponse | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add:
      obj.add === undefined
        ? undefined
        : Object.entries(obj.add).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    remove: obj.remove?.map((y) => y),
    set:
      obj.set === undefined
        ? undefined
        : Object.entries(obj.set).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchAuthority
 */
export interface VirtualServiceSpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchAuthority#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchAuthority(
  obj: VirtualServiceSpecHttpMatchAuthority | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchHeaders
 */
export interface VirtualServiceSpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchHeaders#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchHeaders(
  obj: VirtualServiceSpecHttpMatchHeaders | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchMethod
 */
export interface VirtualServiceSpecHttpMatchMethod {
  /**
   * @schema VirtualServiceSpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchMethod#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchMethod(
  obj: VirtualServiceSpecHttpMatchMethod | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchQueryParams
 */
export interface VirtualServiceSpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchQueryParams(
  obj: VirtualServiceSpecHttpMatchQueryParams | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchScheme
 */
export interface VirtualServiceSpecHttpMatchScheme {
  /**
   * @schema VirtualServiceSpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchScheme#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchScheme(
  obj: VirtualServiceSpecHttpMatchScheme | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchUri
 */
export interface VirtualServiceSpecHttpMatchUri {
  /**
   * @schema VirtualServiceSpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchUri#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchUri(
  obj: VirtualServiceSpecHttpMatchUri | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceSpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMatchWithoutHeaders(
  obj: VirtualServiceSpecHttpMatchWithoutHeaders | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exact: obj.exact,
    prefix: obj.prefix,
    regex: obj.regex
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpMirrorPort
 */
export interface VirtualServiceSpecHttpMirrorPort {
  /**
   * @schema VirtualServiceSpecHttpMirrorPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPort(
  obj: VirtualServiceSpecHttpMirrorPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteDestination
 */
export interface VirtualServiceSpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#host
   */
  readonly host?: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestination(
  obj: VirtualServiceSpecHttpRouteDestination | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: toJson_VirtualServiceSpecHttpRouteDestinationPort(obj.port),
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeaders
 */
export interface VirtualServiceSpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpRouteHeadersResponse;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeaders(
  obj: VirtualServiceSpecHttpRouteHeaders | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    request: toJson_VirtualServiceSpecHttpRouteHeadersRequest(obj.request),
    response: toJson_VirtualServiceSpecHttpRouteHeadersResponse(obj.response)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTcpRouteDestination
 */
export interface VirtualServiceSpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#host
   */
  readonly host?: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestination(
  obj: VirtualServiceSpecTcpRouteDestination | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: toJson_VirtualServiceSpecTcpRouteDestinationPort(obj.port),
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecTlsRouteDestination
 */
export interface VirtualServiceSpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#host
   */
  readonly host?: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#subset
   */
  readonly subset?: string;
}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestination(
  obj: VirtualServiceSpecTlsRouteDestination | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: toJson_VirtualServiceSpecTlsRouteDestinationPort(obj.port),
    subset: obj.subset
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceSpecHttpFaultAbortPercentage
 */
export interface VirtualServiceSpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbortPercentage(
  obj: VirtualServiceSpecHttpFaultAbortPercentage | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    value: obj.value
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceSpecHttpFaultDelayPercentage
 */
export interface VirtualServiceSpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelayPercentage(
  obj: VirtualServiceSpecHttpFaultDelayPercentage | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    value: obj.value
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpRouteDestinationPort
 */
export interface VirtualServiceSpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecHttpRouteDestinationPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestinationPort(
  obj: VirtualServiceSpecHttpRouteDestinationPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersRequest
 */
export interface VirtualServiceSpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersRequest(
  obj: VirtualServiceSpecHttpRouteHeadersRequest | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add:
      obj.add === undefined
        ? undefined
        : Object.entries(obj.add).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    remove: obj.remove?.map((y) => y),
    set:
      obj.set === undefined
        ? undefined
        : Object.entries(obj.set).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersResponse
 */
export interface VirtualServiceSpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };
}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersResponse(
  obj: VirtualServiceSpecHttpRouteHeadersResponse | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add:
      obj.add === undefined
        ? undefined
        : Object.entries(obj.add).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    remove: obj.remove?.map((y) => y),
    set:
      obj.set === undefined
        ? undefined
        : Object.entries(obj.set).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTcpRouteDestinationPort
 */
export interface VirtualServiceSpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTcpRouteDestinationPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestinationPort(
  obj: VirtualServiceSpecTcpRouteDestinationPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTlsRouteDestinationPort
 */
export interface VirtualServiceSpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTlsRouteDestinationPort#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestinationPort(
  obj: VirtualServiceSpecTlsRouteDestinationPort | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    number: obj.number
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 *
 *
 * @schema WorkloadEntry
 */
export class WorkloadEntry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadEntry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'WorkloadEntry'
  };

  /**
   * Renders a Kubernetes manifest for "WorkloadEntry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadEntryProps = {}): any {
    return {
      ...WorkloadEntry.GVK,
      ...toJson_WorkloadEntryProps(props)
    };
  }

  /**
   * Defines a "WorkloadEntry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadEntryProps = {}) {
    super(scope, id, {
      ...WorkloadEntry.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadEntry.GVK,
      ...toJson_WorkloadEntryProps(resolved)
    };
  }
}

/**
 * @schema WorkloadEntry
 */
export interface WorkloadEntryProps {
  /**
   * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
   *
   * @schema WorkloadEntry#spec
   */
  readonly spec?: WorkloadEntrySpec;

  /**
   * @schema WorkloadEntry#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'WorkloadEntryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadEntryProps(obj: WorkloadEntryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_WorkloadEntrySpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
 *
 * @schema WorkloadEntrySpec
 */
export interface WorkloadEntrySpec {
  /**
   * @schema WorkloadEntrySpec#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#locality
   */
  readonly locality?: string;

  /**
   * @schema WorkloadEntrySpec#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * @schema WorkloadEntrySpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'WorkloadEntrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadEntrySpec(obj: WorkloadEntrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    address: obj.address,
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    locality: obj.locality,
    network: obj.network,
    ports:
      obj.ports === undefined
        ? undefined
        : Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    serviceAccount: obj.serviceAccount,
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 *
 *
 * @schema WorkloadGroup
 */
export class WorkloadGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'WorkloadGroup'
  };

  /**
   * Renders a Kubernetes manifest for "WorkloadGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupProps = {}): any {
    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(props)
    };
  }

  /**
   * Defines a "WorkloadGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupProps = {}) {
    super(scope, id, {
      ...WorkloadGroup.GVK,
      ...props
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(resolved)
    };
  }
}

/**
 * @schema WorkloadGroup
 */
export interface WorkloadGroupProps {
  /**
   * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
   *
   * @schema WorkloadGroup#spec
   */
  readonly spec?: WorkloadGroupSpec;

  /**
   * @schema WorkloadGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;
}

/**
 * Converts an object of type 'WorkloadGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupProps(obj: WorkloadGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    spec: toJson_WorkloadGroupSpec(obj.spec),
    metadata: obj.metadata
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
 *
 * @schema WorkloadGroupSpec
 */
export interface WorkloadGroupSpec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupSpec#metadata
   */
  readonly metadata?: WorkloadGroupSpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupSpec#probe
   */
  readonly probe?: WorkloadGroupSpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupSpec#template
   */
  readonly template?: WorkloadGroupSpecTemplate;
}

/**
 * Converts an object of type 'WorkloadGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpec(obj: WorkloadGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_WorkloadGroupSpecMetadata(obj.metadata),
    probe: toJson_WorkloadGroupSpecProbe(obj.probe),
    template: toJson_WorkloadGroupSpecTemplate(obj.template)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupSpecMetadata
 */
export interface WorkloadGroupSpecMetadata {
  /**
   * @schema WorkloadGroupSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'WorkloadGroupSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecMetadata(
  obj: WorkloadGroupSpecMetadata | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {})
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupSpecProbe
 */
export interface WorkloadGroupSpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupSpecProbe#exec
   */
  readonly exec?: WorkloadGroupSpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupSpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * @schema WorkloadGroupSpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupSpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupSpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupSpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupSpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupSpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupSpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupSpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'WorkloadGroupSpecProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbe(
  obj: WorkloadGroupSpecProbe | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_WorkloadGroupSpecProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    httpGet: toJson_WorkloadGroupSpecProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_WorkloadGroupSpecProbeTcpSocket(obj.tcpSocket),
    timeoutSeconds: obj.timeoutSeconds
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupSpecTemplate
 */
export interface WorkloadGroupSpecTemplate {
  /**
   * @schema WorkloadGroupSpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * @schema WorkloadGroupSpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * @schema WorkloadGroupSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#weight
   */
  readonly weight?: number;
}

/**
 * Converts an object of type 'WorkloadGroupSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecTemplate(
  obj: WorkloadGroupSpecTemplate | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    address: obj.address,
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    locality: obj.locality,
    network: obj.network,
    ports:
      obj.ports === undefined
        ? undefined
        : Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    serviceAccount: obj.serviceAccount,
    weight: obj.weight
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupSpecProbeExec
 */
export interface WorkloadGroupSpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupSpecProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeExec(
  obj: WorkloadGroupSpecProbeExec | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y)
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkloadGroupSpecProbeHttpGet
 */
export interface WorkloadGroupSpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupSpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#port
   */
  readonly port?: number;

  /**
   * @schema WorkloadGroupSpecProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGet(
  obj: WorkloadGroupSpecProbeHttpGet | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) => toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(y)),
    path: obj.path,
    port: obj.port,
    scheme: obj.scheme
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupSpecProbeTcpSocket
 */
export interface WorkloadGroupSpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeTcpSocket(
  obj: WorkloadGroupSpecProbeTcpSocket | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupSpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(
  obj: WorkloadGroupSpecProbeHttpGetHttpHeaders | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
